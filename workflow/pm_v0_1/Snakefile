# workflow/pm_v0_1/Snakefile
# v0.1 contract-first pipeline: similarity + structural summaries + safety flags
from __future__ import annotations

import csv
import hashlib
import json
from datetime import datetime, timezone
from pathlib import Path
import shutil



def _find_repo_root(start: Path) -> Path:
    for p in [start] + list(start.parents):
        if (p / "envs").is_dir():
            return p
    return start

try:
    _snakefile_dir = Path(workflow.snakefile).resolve().parent
except Exception:
    _snakefile_dir = Path.cwd()

REPO_ROOT = _find_repo_root(_snakefile_dir)
ENVS_DIR = REPO_ROOT / "envs"

def conda_env(filename: str) -> str:
    """Return absolute path to an env YAML in <repo>/envs/."""
    return str(ENVS_DIR / filename)

CONDA_AVAILABLE = shutil.which("conda") is not None

# ---------- Helpers ----------
def read_tsv(path: str):
    with open(path, newline="") as f:
        r = csv.DictReader(f, delimiter="\t")
        return [row for row in r]

def list_phage_ids(manifest_path: str):
    return [r["phage_id"] for r in read_tsv(manifest_path)]

def list_host_ids(manifest_path: str):
    return [r["host_id"] for r in read_tsv(manifest_path)]

def sha256_or_none(path: str | Path) -> str | None:
    p = Path(path)
    if not p.exists():
        return None
    h = hashlib.sha256()
    with p.open("rb") as f:
        for chunk in iter(lambda: f.read(1024 * 1024), b""):
            h.update(chunk)
    return h.hexdigest()

def iso_utc() -> str:
    return datetime.now(timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")

def get_phage_rows():
    return read_tsv(PHAGE_MANIFEST)

def get_host_rows():
    return read_tsv(HOST_MANIFEST)

def phage_fasta(phage_id: str) -> str:
    return next(r["fasta"] for r in get_phage_rows() if r["phage_id"] == phage_id)

def host_genome(host_id: str) -> str:
    return next(r["genome_fna"] for r in get_host_rows() if r["host_id"] == host_id)

def host_proteome(host_id: str) -> str:
    return next(r["proteome_faa"] for r in get_host_rows() if r["host_id"] == host_id)

_manifests_cfg = (config.get("manifests", {}) or {})
PHAGE_MANIFEST = _manifests_cfg.get("phages", "manifests/phages.tsv")
HOST_MANIFEST = _manifests_cfg.get("hosts", "manifests/hosts.tsv")

PHAGE_IDS = list_phage_ids(PHAGE_MANIFEST)
HOST_IDS = list_host_ids(HOST_MANIFEST)

_dirs_cfg = (config.get("directories", {}) or {})
CACHE_DIR = Path(_dirs_cfg.get("cache", "cache"))
RANKINGS_DIR = Path(_dirs_cfg.get("rankings", "rankings"))
RESULTS_VIEW_DIR = None
_results_viewer = _dirs_cfg.get("results_viewer")
if _results_viewer:
    RESULTS_VIEW_DIR = Path(_results_viewer)

# Feature artefact locations
SIM_DIR = CACHE_DIR / "features" / "similarity"
STRUCT_DIR = CACHE_DIR / "features" / "structural"
SAFETY_DIR = CACHE_DIR / "features" / "safety"

# Foldseek DB cache (accelerated)
FOLDSEEK_DIR = CACHE_DIR / "foldseek"
PHAGE_STRUCT_DIR = Path(config.get("structures", {}).get("phage_library_dir", str(CACHE_DIR / "structures" / "phages")))
HOST_STRUCT_DIR = Path(config.get("structures", {}).get("hosts_dir", str(CACHE_DIR / "structures" / "hosts")))

# Module toggles
TEST_MODE = bool(config.get("modules", {}).get("test_mode", False))
ENABLE_SIM = bool(config.get("modules", {}).get("enable_sourmash", False))
ENABLE_STRUCT = bool(config.get("modules", {}).get("enable_structural_ppi", False))
ENABLE_SAFETY = bool(config.get("modules", {}).get("enable_safety", False))

# Conda env choices (avoid heavy tool installs in test mode)
CORE_ENV = conda_env("core.yml") if CONDA_AVAILABLE else None
SOURMASH_ENV = CORE_ENV if TEST_MODE else (conda_env("sourmash.yml") if CONDA_AVAILABLE else None)
FOLDSEEK_ENV = CORE_ENV if TEST_MODE else (conda_env("foldseek.yml") if CONDA_AVAILABLE else None)
PROKKA_ENV = CORE_ENV if TEST_MODE else (conda_env("prokka.yml") if CONDA_AVAILABLE else None)
ABRICATE_ENV = CORE_ENV if TEST_MODE else (conda_env("abricate.yml") if CONDA_AVAILABLE else None)


# ---------- Output targets ----------
def ranking_csv(host_id: str) -> str:
    return str(RANKINGS_DIR / host_id / "ranking.csv")

def evidence_json(host_id: str) -> str:
    return str(RANKINGS_DIR / host_id / "evidence_bundle.json")

def results_ranking_csv(host_id: str) -> str:
    if RESULTS_VIEW_DIR is None:
        raise ValueError("results_viewer directory is not configured.")
    return str(RESULTS_VIEW_DIR / host_id / "ranking.csv")

def results_evidence_json(host_id: str) -> str:
    if RESULTS_VIEW_DIR is None:
        raise ValueError("results_viewer directory is not configured.")
    return str(RESULTS_VIEW_DIR / host_id / "evidence_bundle.json")

def similarity_json(host_id: str, phage_id: str) -> str:
    return str(SIM_DIR / host_id / f"{phage_id}.json")

def structural_json(host_id: str, phage_id: str) -> str:
    return str(STRUCT_DIR / host_id / f"{phage_id}.json")

def safety_json(phage_id: str) -> str:
    return str(SAFETY_DIR / f"{phage_id}.json")

def similarity_meta_path(host_id: str) -> str:
    return str(SIM_DIR / host_id / "meta.json")

def structural_meta_path(host_id: str) -> str:
    return str(STRUCT_DIR / host_id / "meta.json")

def safety_meta_path() -> str:
    return str(SAFETY_DIR / "meta.json")

def test_plan_md(host_id: str) -> str:
    return str(RANKINGS_DIR / host_id / "test_plan.md")

def structural_outputs(wc):
    return [structural_json(wc.host_id, pid) for pid in PHAGE_IDS]

def similarity_outputs(wc):
    return [similarity_json(wc.host_id, pid) for pid in PHAGE_IDS]

def safety_outputs():
    return [safety_json(pid) for pid in PHAGE_IDS]


rule all:
    input:
        expand(str(RANKINGS_DIR / "{host_id}" / "ranking.csv"), host_id=HOST_IDS),
        expand(str(RANKINGS_DIR / "{host_id}" / "evidence_bundle.json"), host_id=HOST_IDS),
        expand(str(RANKINGS_DIR / "{host_id}" / "test_plan.md"), host_id=HOST_IDS),
        expand(str(RANKINGS_DIR / "{host_id}" / "VALIDATED.txt"), host_id=HOST_IDS),
        *(expand(str(RESULTS_VIEW_DIR / "{host_id}" / "ranking.csv"), host_id=HOST_IDS) if RESULTS_VIEW_DIR else []),
        *(expand(str(RESULTS_VIEW_DIR / "{host_id}" / "evidence_bundle.json"), host_id=HOST_IDS) if RESULTS_VIEW_DIR else []),
        *(expand(similarity_meta_path("{host_id}"), host_id=HOST_IDS) if ENABLE_SIM else []),
        *(expand(structural_meta_path("{host_id}"), host_id=HOST_IDS) if ENABLE_STRUCT else []),
        *([safety_meta_path()] if ENABLE_SAFETY else [])


# ---------- Similarity module (sourmash) ----------
# Cache sketches (real mode). In test mode we bypass tools and directly emit mock feature JSON.
rule sourmash_sketch_phage:
    input:
        lambda wc: next(r["fasta"] for r in read_tsv(PHAGE_MANIFEST) if r["phage_id"] == wc.phage_id)
    output:
        str(CACHE_DIR / "sourmash" / "phages" / "{phage_id}.sig")
    conda:
        SOURMASH_ENV
    threads: 1
    shell:
        r"""
        mkdir -p {CACHE_DIR}/sourmash/phages
        sourmash sketch dna -k {config[params][sourmash_k]} --scaled {config[params][sourmash_scaled]} -o {output} {input}
        """

rule sourmash_sketch_host:
    input:
        lambda wc: next(r["genome_fna"] for r in read_tsv(HOST_MANIFEST) if r["host_id"] == wc.host_id)
    output:
        str(CACHE_DIR / "sourmash" / "hosts" / "{host_id}.sig")
    conda:
        SOURMASH_ENV
    threads: 1
    shell:
        r"""
        mkdir -p {CACHE_DIR}/sourmash/hosts
        sourmash sketch dna -k {config[params][sourmash_k]} --scaled {config[params][sourmash_scaled]} -o {output} {input}
        """

rule similarity_feature:
    input:
        lambda wc: [] if TEST_MODE else {"host_sig": str(CACHE_DIR / "sourmash" / "hosts" / f"{wc.host_id}.sig"),
                                         "phage_sig": str(CACHE_DIR / "sourmash" / "phages" / f"{wc.phage_id}.sig")}
    output:
        str(SIM_DIR / "{host_id}" / "{phage_id}.json")
    conda:
        SOURMASH_ENV
    threads: 1
    params:
        cmd=lambda wc, input, output: (
            f"python scripts/modules/sourmash_containment.py --host-id {wc.host_id} --phage-id {wc.phage_id} "
            f"--out {output} "
            + ("--mock" if TEST_MODE else f"--host-sig {input['host_sig']} --phage-sig {input['phage_sig']}")
        )
    shell:
        "{params.cmd}"


rule similarity_meta:
    input:
        similarity_outputs
    output:
        similarity_meta_path("{host_id}")
    run:
        out = Path(output[0])
        out.parent.mkdir(parents=True, exist_ok=True)
        phages = [{"phage_id": pid, "fasta": phage_fasta(pid), "sha256": sha256_or_none(phage_fasta(pid))} for pid in PHAGE_IDS]
        meta = {
            "module": "similarity",
            "generated_at": iso_utc(),
            "test_mode": TEST_MODE,
            "tool": "mock" if TEST_MODE else "sourmash",
            "tool_version": (config.get("versions", {}) or {}).get("sourmash"),
            "params": {
                "sourmash_k": (config.get("params", {}) or {}).get("sourmash_k"),
                "sourmash_scaled": (config.get("params", {}) or {}).get("sourmash_scaled"),
            },
            "inputs": {
                "host_genome": {"path": host_genome(wildcards.host_id), "sha256": sha256_or_none(host_genome(wildcards.host_id))},
                "host_proteome": {"path": host_proteome(wildcards.host_id), "sha256": sha256_or_none(host_proteome(wildcards.host_id))},
                "phages": phages,
            },
            "manifest_hashes": {
                Path(PHAGE_MANIFEST).name: sha256_or_none(PHAGE_MANIFEST),
                Path(HOST_MANIFEST).name: sha256_or_none(HOST_MANIFEST),
            },
        }
        out.write_text(json.dumps(meta, indent=2))


# ---------- Safety module (abricate + lysogeny flags) ----------
rule prokka_annotate_phage:
    input:
        lambda wc: next(r["fasta"] for r in read_tsv(PHAGE_MANIFEST) if r["phage_id"] == wc.phage_id)
    output:
        gff=str(CACHE_DIR / "annotations" / "phages" / "{phage_id}" / "{phage_id}.gff")
    conda:
        PROKKA_ENV
    threads: 2
    shell:
        r"""
        outdir={CACHE_DIR}/annotations/phages/{wildcards.phage_id}
        mkdir -p $outdir
        prokka --outdir $outdir --prefix {wildcards.phage_id} --kingdom Viruses --cpus {threads} {input}
        # prokka writes <prefix>.gff in outdir
        """

rule abricate_vfdb_phage:
    input:
        lambda wc: next(r["fasta"] for r in read_tsv(PHAGE_MANIFEST) if r["phage_id"] == wc.phage_id)
    output:
        str(CACHE_DIR / "safety" / "abricate" / "{phage_id}.tsv")
    conda:
        ABRICATE_ENV
    threads: 1
    shell:
        r"""
        mkdir -p {CACHE_DIR}/safety/abricate
        # Requires user to have abricate databases set up (abricate --setupdb).
        abricate --db vfdb {input} > {output} || true
        """

rule safety_feature:
    input:
        lambda wc: [] if TEST_MODE else {
            "abricate": str(CACHE_DIR / "safety" / "abricate" / f"{wc.phage_id}.tsv"),
            "gff": str(CACHE_DIR / "annotations" / "phages" / f"{wc.phage_id}" / f"{wc.phage_id}.gff"),
        }
    output:
        str(SAFETY_DIR / "{phage_id}.json")
    conda:
        CORE_ENV
    threads: 1
    params:
        cmd=lambda wc, input, output: (
            f"python scripts/modules/safety_compile.py --phage-id {wc.phage_id} --out {output} "
            + ("--mock" if TEST_MODE else f"--abricate-tsv {input['abricate']} --gff {input['gff']}")
        )
    shell:
        "{params.cmd}"


rule safety_meta:
    input:
        safety_outputs
    output:
        safety_meta_path()
    run:
        out = Path(output[0])
        out.parent.mkdir(parents=True, exist_ok=True)
        phage_inputs = []
        for pid in PHAGE_IDS:
            fasta = phage_fasta(pid)
            abricate = CACHE_DIR / "safety" / "abricate" / f"{pid}.tsv"
            gff = CACHE_DIR / "annotations" / "phages" / pid / f"{pid}.gff"
            phage_inputs.append({
                "phage_id": pid,
                "fasta": {"path": fasta, "sha256": sha256_or_none(fasta)},
                "abricate_tsv": {"path": str(abricate), "sha256": sha256_or_none(abricate)},
                "gff": {"path": str(gff), "sha256": sha256_or_none(gff)},
            })
        meta = {
            "module": "safety",
            "generated_at": iso_utc(),
            "test_mode": TEST_MODE,
            "tool": "mock" if TEST_MODE else "abricate/prokka",
            "tool_version": (config.get("versions", {}) or {}).get("abricate"),
            "params": {},
            "inputs": {
                "phages": phage_inputs,
            },
            "manifest_hashes": {
                Path(PHAGE_MANIFEST).name: sha256_or_none(PHAGE_MANIFEST),
            },
        }
        out.write_text(json.dumps(meta, indent=2))


# ---------- Structural module (Foldseek summaries) ----------
rule foldseek_createdb_phage:
    input:
        # Expect structures already present (outside scope of v0.1), one folder per phage_id under PHAGE_STRUCT_DIR.
        expand(str(PHAGE_STRUCT_DIR / "{phage_id}"), phage_id=PHAGE_IDS)
    output:
        str(FOLDSEEK_DIR / "db" / "phageDB.dbtype")
    conda:
        FOLDSEEK_ENV
    threads: 2
    shell:
        r"""
        mkdir -p {FOLDSEEK_DIR}/db
        # createdb accepts a folder of structures. Users should populate {PHAGE_STRUCT_DIR} beforehand.
        foldseek createdb {PHAGE_STRUCT_DIR} {FOLDSEEK_DIR}/db/phageDB
        touch {output}
        """

rule foldseek_createdb_host:
    input:
        lambda wc: str(HOST_STRUCT_DIR / wc.host_id)
    output:
        str(FOLDSEEK_DIR / "db" / "hosts" / "{host_id}" / "hostDB.dbtype")
    conda:
        FOLDSEEK_ENV
    threads: 2
    shell:
        r"""
        mkdir -p {FOLDSEEK_DIR}/db/hosts/{wildcards.host_id}
        foldseek createdb {input} {FOLDSEEK_DIR}/db/hosts/{wildcards.host_id}/hostDB
        touch {output}
        """

rule foldseek_search_host_vs_phage:
    input:
        phagedb=str(FOLDSEEK_DIR / "db" / "phageDB.dbtype"),
        hostdb=str(FOLDSEEK_DIR / "db" / "hosts" / "{host_id}" / "hostDB.dbtype")
    output:
        str(FOLDSEEK_DIR / "results" / "{host_id}" / "hits.tsv")
    conda:
        FOLDSEEK_ENV
    threads: 4
    shell:
        r"""
        mkdir -p {FOLDSEEK_DIR}/results/{wildcards.host_id}
        mkdir -p {FOLDSEEK_DIR}/tmp/{wildcards.host_id}
        # result DB prefix
        foldseek search {FOLDSEEK_DIR}/db/hosts/{wildcards.host_id}/hostDB {FOLDSEEK_DIR}/db/phageDB {FOLDSEEK_DIR}/results/{wildcards.host_id}/alnDB {FOLDSEEK_DIR}/tmp/{wildcards.host_id} --threads {threads} || true
        foldseek convertalis {FOLDSEEK_DIR}/db/hosts/{wildcards.host_id}/hostDB {FOLDSEEK_DIR}/db/phageDB {FOLDSEEK_DIR}/results/{wildcards.host_id}/alnDB {output} --format-mode 4 --format-output query,target,evalue,bits,qcov,tcov || true
        # Ensure an output file exists even if Foldseek fails (bundle marks evidence as empty)
        touch {output}
        """

rule structural_features:
    input:
        lambda wc: [] if TEST_MODE else {"hits": str(FOLDSEEK_DIR / "results" / wc.host_id / "hits.tsv")}
    output:
        directory(str(STRUCT_DIR / "{host_id}"))
    conda:
        CORE_ENV
    threads: 1
    params:
        phage_ids=",".join(PHAGE_IDS),
        out_dir=lambda wc: str(STRUCT_DIR / wc.host_id),
        cmd=lambda wc, input, output: (
            f"python scripts/modules/foldseek_summarise.py --host-id {wc.host_id} --phage-ids {','.join(PHAGE_IDS)} "
            f"--out-dir {STRUCT_DIR / wc.host_id} "
            + ("--mock" if TEST_MODE else f"--hits-tsv {input['hits']}")
        )
    shell:
        "{params.cmd}"


rule structural_meta:
    input:
        rules.structural_features.output
    output:
        structural_meta_path("{host_id}")
    run:
        out = Path(output[0])
        out.parent.mkdir(parents=True, exist_ok=True)
        hits = FOLDSEEK_DIR / "results" / wildcards.host_id / "hits.tsv"
        meta = {
            "module": "structural",
            "generated_at": iso_utc(),
            "test_mode": TEST_MODE,
            "tool": "mock" if TEST_MODE else "foldseek",
            "tool_version": (config.get("versions", {}) or {}).get("foldseek"),
            "params": {
                "foldseek_evalue_max": (config.get("params", {}) or {}).get("foldseek_evalue_max"),
            },
            "inputs": {
                "host_id": wildcards.host_id,
                "hits_tsv": {"path": str(hits), "sha256": sha256_or_none(hits)},
                "phage_structures_dir": str(PHAGE_STRUCT_DIR),
                "host_structures_dir": str(HOST_STRUCT_DIR / wildcards.host_id),
            },
            "manifest_hashes": {
                Path(PHAGE_MANIFEST).name: sha256_or_none(PHAGE_MANIFEST),
                Path(HOST_MANIFEST).name: sha256_or_none(HOST_MANIFEST),
            },
        }
        out.write_text(json.dumps(meta, indent=2))


# ---------- Decision bundle assembly ----------
rule decision_bundle:
    input:
        similarity = (lambda wc: expand(rules.similarity_feature.output, host_id=wc.host_id, phage_id=PHAGE_IDS)) if ENABLE_SIM else [],
        structural = rules.structural_features.output if ENABLE_STRUCT else [],
        safety = (lambda wc: expand(rules.safety_feature.output, phage_id=PHAGE_IDS)) if ENABLE_SAFETY else []
    output:
        ranking=str(RANKINGS_DIR / "{host_id}" / "ranking.csv"),
        evidence=str(RANKINGS_DIR / "{host_id}" / "evidence_bundle.json")
    conda:
        CORE_ENV
    threads: 1
    shell:
        "python scripts/assemble_decision_bundle.py --host-id {wildcards.host_id} "
        "--config config.yaml --phage-manifest {PHAGE_MANIFEST} --host-manifest {HOST_MANIFEST} "
        "--similarity-dir {SIM_DIR} --structural-dir {STRUCT_DIR} --safety-dir {SAFETY_DIR} "
        "--out-ranking {output.ranking} --out-evidence {output.evidence}"

rule test_plan:
    input:
        ranking=lambda wc: ranking_csv(wc.host_id),
        evidence=lambda wc: evidence_json(wc.host_id)
    output:
        test_plan_md("{host_id}")
    params:
        top_n=lambda wc: (config.get("params", {}) or {}).get("top_n", 10)
    conda:
        CORE_ENV
    threads: 1
    shell:
        "python scripts/build_test_plan.py --ranking {input.ranking} --evidence {input.evidence} "
        "--out {output} --top-n {params.top_n}"

# Validate outputs (optional but useful for CI/demo)
rule validate_decision_bundle:
    input:
        ranking=lambda wc: ranking_csv(wc.host_id),
        evidence=lambda wc: evidence_json(wc.host_id),
        schema="contracts/decision_bundle/evidence_bundle.schema.json"
    output:
        touch(str(RANKINGS_DIR / "{host_id}" / "VALIDATED.txt"))
    conda:
        CORE_ENV
    threads: 1
    shell:
        "python scripts/validate_decision_bundle.py --ranking {input.ranking} "
        "--evidence {input.evidence} --schema {input.schema} "
        "&& echo. > {output}"

if RESULTS_VIEW_DIR:
    rule publish_results:
        input:
            ranking=lambda wc: ranking_csv(wc.host_id),
            evidence=lambda wc: evidence_json(wc.host_id)
        output:
            ranking=str(RESULTS_VIEW_DIR / "{host_id}" / "ranking.csv"),
            evidence=str(RESULTS_VIEW_DIR / "{host_id}" / "evidence_bundle.json")
        run:
            out_rank = Path(output.ranking)
            out_rank.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(input.ranking, out_rank)
            out_ev = Path(output.evidence)
            out_ev.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(input.evidence, out_ev)

rule validate:
    input:
        expand(str(RANKINGS_DIR / "{host_id}" / "VALIDATED.txt"), host_id=HOST_IDS)
