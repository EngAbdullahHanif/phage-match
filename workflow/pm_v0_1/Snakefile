# workflow/pm_v0_1/Snakefile
# v0.1 contract-first pipeline: similarity + structural summaries + safety flags
from __future__ import annotations

import csv
from pathlib import Path
import shutil



def _find_repo_root(start: Path) -> Path:
    for p in [start] + list(start.parents):
        if (p / "envs").is_dir():
            return p
    return start

try:
    _snakefile_dir = Path(workflow.snakefile).resolve().parent
except Exception:
    _snakefile_dir = Path.cwd()

REPO_ROOT = _find_repo_root(_snakefile_dir)
ENVS_DIR = REPO_ROOT / "envs"

def conda_env(filename: str) -> str:
    """Return absolute path to an env YAML in <repo>/envs/."""
    return str(ENVS_DIR / filename)

CONDA_AVAILABLE = shutil.which("conda") is not None

# ---------- Helpers ----------
def read_tsv(path: str):
    with open(path, newline="") as f:
        r = csv.DictReader(f, delimiter="\t")
        return [row for row in r]

def list_phage_ids(manifest_path: str):
    return [r["phage_id"] for r in read_tsv(manifest_path)]

def list_host_ids(manifest_path: str):
    return [r["host_id"] for r in read_tsv(manifest_path)]

PHAGE_MANIFEST = "manifests/phages.tsv"
HOST_MANIFEST = "manifests/hosts.tsv"

PHAGE_IDS = list_phage_ids(PHAGE_MANIFEST)
HOST_IDS = list_host_ids(HOST_MANIFEST)

CACHE_DIR = Path(config["directories"]["cache"])
RANKINGS_DIR = Path(config["directories"]["rankings"])

# Feature artefact locations
SIM_DIR = CACHE_DIR / "features" / "similarity"
STRUCT_DIR = CACHE_DIR / "features" / "structural"
SAFETY_DIR = CACHE_DIR / "features" / "safety"

# Foldseek DB cache (accelerated)
FOLDSEEK_DIR = CACHE_DIR / "foldseek"
PHAGE_STRUCT_DIR = Path(config.get("structures", {}).get("phage_library_dir", str(CACHE_DIR / "structures" / "phages")))
HOST_STRUCT_DIR = Path(config.get("structures", {}).get("hosts_dir", str(CACHE_DIR / "structures" / "hosts")))

# Module toggles
TEST_MODE = bool(config.get("modules", {}).get("test_mode", False))
ENABLE_SIM = bool(config.get("modules", {}).get("enable_sourmash", False))
ENABLE_STRUCT = bool(config.get("modules", {}).get("enable_structural_ppi", False))
ENABLE_SAFETY = bool(config.get("modules", {}).get("enable_safety", False))

# Conda env choices (avoid heavy tool installs in test mode)
CORE_ENV = conda_env("core.yml") if CONDA_AVAILABLE else None
SOURMASH_ENV = CORE_ENV if TEST_MODE else (conda_env("sourmash.yml") if CONDA_AVAILABLE else None)
FOLDSEEK_ENV = CORE_ENV if TEST_MODE else (conda_env("foldseek.yml") if CONDA_AVAILABLE else None)
PROKKA_ENV = CORE_ENV if TEST_MODE else (conda_env("prokka.yml") if CONDA_AVAILABLE else None)
ABRICATE_ENV = CORE_ENV if TEST_MODE else (conda_env("abricate.yml") if CONDA_AVAILABLE else None)


# ---------- Output targets ----------
def ranking_csv(host_id: str) -> str:
    return str(RANKINGS_DIR / host_id / "ranking.csv")

def evidence_json(host_id: str) -> str:
    return str(RANKINGS_DIR / host_id / "evidence_bundle.json")

def similarity_json(host_id: str, phage_id: str) -> str:
    return str(SIM_DIR / host_id / f"{phage_id}.json")

def structural_json(host_id: str, phage_id: str) -> str:
    return str(STRUCT_DIR / host_id / f"{phage_id}.json")

def safety_json(phage_id: str) -> str:
    return str(SAFETY_DIR / f"{phage_id}.json")

def structural_outputs(wc):
    return [structural_json(wc.host_id, pid) for pid in PHAGE_IDS]

def similarity_outputs(wc):
    return [similarity_json(wc.host_id, pid) for pid in PHAGE_IDS]

def safety_outputs():
    return [safety_json(pid) for pid in PHAGE_IDS]


rule all:
    input:
        expand(str(RANKINGS_DIR / "{host_id}" / "ranking.csv"), host_id=HOST_IDS),
        expand(str(RANKINGS_DIR / "{host_id}" / "evidence_bundle.json"), host_id=HOST_IDS),
        expand(str(RANKINGS_DIR / "{host_id}" / "VALIDATED.txt"), host_id=HOST_IDS)


# ---------- Similarity module (sourmash) ----------
# Cache sketches (real mode). In test mode we bypass tools and directly emit mock feature JSON.
rule sourmash_sketch_phage:
    input:
        lambda wc: next(r["fasta"] for r in read_tsv(PHAGE_MANIFEST) if r["phage_id"] == wc.phage_id)
    output:
        str(CACHE_DIR / "sourmash" / "phages" / "{phage_id}.sig")
    conda:
        SOURMASH_ENV
    threads: 1
    shell:
        r"""
        mkdir -p {CACHE_DIR}/sourmash/phages
        sourmash sketch dna -k {config[params][sourmash_k]} --scaled {config[params][sourmash_scaled]} -o {output} {input}
        """

rule sourmash_sketch_host:
    input:
        lambda wc: next(r["genome_fna"] for r in read_tsv(HOST_MANIFEST) if r["host_id"] == wc.host_id)
    output:
        str(CACHE_DIR / "sourmash" / "hosts" / "{host_id}.sig")
    conda:
        SOURMASH_ENV
    threads: 1
    shell:
        r"""
        mkdir -p {CACHE_DIR}/sourmash/hosts
        sourmash sketch dna -k {config[params][sourmash_k]} --scaled {config[params][sourmash_scaled]} -o {output} {input}
        """

rule similarity_feature:
    input:
        lambda wc: [] if TEST_MODE else {"host_sig": str(CACHE_DIR / "sourmash" / "hosts" / f"{wc.host_id}.sig"),
                                         "phage_sig": str(CACHE_DIR / "sourmash" / "phages" / f"{wc.phage_id}.sig")}
    output:
        str(SIM_DIR / "{host_id}" / "{phage_id}.json")
    conda:
        SOURMASH_ENV
    threads: 1
    params:
        cmd=lambda wc, input, output: (
            f"python scripts/modules/sourmash_containment.py --host-id {wc.host_id} --phage-id {wc.phage_id} "
            f"--out {output} "
            + ("--mock" if TEST_MODE else f"--host-sig {input['host_sig']} --phage-sig {input['phage_sig']}")
        )
    shell:
        "{params.cmd}"


# ---------- Safety module (abricate + lysogeny flags) ----------
rule prokka_annotate_phage:
    input:
        lambda wc: next(r["fasta"] for r in read_tsv(PHAGE_MANIFEST) if r["phage_id"] == wc.phage_id)
    output:
        gff=str(CACHE_DIR / "annotations" / "phages" / "{phage_id}" / "{phage_id}.gff")
    conda:
        PROKKA_ENV
    threads: 2
    shell:
        r"""
        outdir={CACHE_DIR}/annotations/phages/{wildcards.phage_id}
        mkdir -p $outdir
        prokka --outdir $outdir --prefix {wildcards.phage_id} --kingdom Viruses --cpus {threads} {input}
        # prokka writes <prefix>.gff in outdir
        """

rule abricate_vfdb_phage:
    input:
        lambda wc: next(r["fasta"] for r in read_tsv(PHAGE_MANIFEST) if r["phage_id"] == wc.phage_id)
    output:
        str(CACHE_DIR / "safety" / "abricate" / "{phage_id}.tsv")
    conda:
        ABRICATE_ENV
    threads: 1
    shell:
        r"""
        mkdir -p {CACHE_DIR}/safety/abricate
        # Requires user to have abricate databases set up (abricate --setupdb).
        abricate --db vfdb {input} > {output} || true
        """

rule safety_feature:
    input:
        lambda wc: [] if TEST_MODE else {
            "abricate": str(CACHE_DIR / "safety" / "abricate" / f"{wc.phage_id}.tsv"),
            "gff": str(CACHE_DIR / "annotations" / "phages" / f"{wc.phage_id}" / f"{wc.phage_id}.gff"),
        }
    output:
        str(SAFETY_DIR / "{phage_id}.json")
    conda:
        CORE_ENV
    threads: 1
    params:
        cmd=lambda wc, input, output: (
            f"python scripts/modules/safety_compile.py --phage-id {wc.phage_id} --out {output} "
            + ("--mock" if TEST_MODE else f"--abricate-tsv {input['abricate']} --gff {input['gff']}")
        )
    shell:
        "{params.cmd}"


# ---------- Structural module (Foldseek summaries) ----------
rule foldseek_createdb_phage:
    input:
        # Expect structures already present (outside scope of v0.1), one folder per phage_id under PHAGE_STRUCT_DIR.
        expand(str(PHAGE_STRUCT_DIR / "{phage_id}"), phage_id=PHAGE_IDS)
    output:
        str(FOLDSEEK_DIR / "db" / "phageDB.dbtype")
    conda:
        FOLDSEEK_ENV
    threads: 2
    shell:
        r"""
        mkdir -p {FOLDSEEK_DIR}/db
        # createdb accepts a folder of structures. Users should populate {PHAGE_STRUCT_DIR} beforehand.
        foldseek createdb {PHAGE_STRUCT_DIR} {FOLDSEEK_DIR}/db/phageDB
        touch {output}
        """

rule foldseek_createdb_host:
    input:
        lambda wc: str(HOST_STRUCT_DIR / wc.host_id)
    output:
        str(FOLDSEEK_DIR / "db" / "hosts" / "{host_id}" / "hostDB.dbtype")
    conda:
        FOLDSEEK_ENV
    threads: 2
    shell:
        r"""
        mkdir -p {FOLDSEEK_DIR}/db/hosts/{wildcards.host_id}
        foldseek createdb {input} {FOLDSEEK_DIR}/db/hosts/{wildcards.host_id}/hostDB
        touch {output}
        """

rule foldseek_search_host_vs_phage:
    input:
        phagedb=str(FOLDSEEK_DIR / "db" / "phageDB.dbtype"),
        hostdb=str(FOLDSEEK_DIR / "db" / "hosts" / "{host_id}" / "hostDB.dbtype")
    output:
        str(FOLDSEEK_DIR / "results" / "{host_id}" / "hits.tsv")
    conda:
        FOLDSEEK_ENV
    threads: 4
    shell:
        r"""
        mkdir -p {FOLDSEEK_DIR}/results/{wildcards.host_id}
        mkdir -p {FOLDSEEK_DIR}/tmp/{wildcards.host_id}
        # result DB prefix
        foldseek search {FOLDSEEK_DIR}/db/hosts/{wildcards.host_id}/hostDB {FOLDSEEK_DIR}/db/phageDB {FOLDSEEK_DIR}/results/{wildcards.host_id}/alnDB {FOLDSEEK_DIR}/tmp/{wildcards.host_id} --threads {threads} || true
        foldseek convertalis {FOLDSEEK_DIR}/db/hosts/{wildcards.host_id}/hostDB {FOLDSEEK_DIR}/db/phageDB {FOLDSEEK_DIR}/results/{wildcards.host_id}/alnDB {output} --format-mode 4 --format-output query,target,evalue,bits,qcov,tcov || true
        # Ensure an output file exists even if Foldseek fails (bundle marks evidence as empty)
        touch {output}
        """

rule structural_features:
    input:
        lambda wc: [] if TEST_MODE else {"hits": str(FOLDSEEK_DIR / "results" / wc.host_id / "hits.tsv")}
    output:
        directory(str(STRUCT_DIR / "{host_id}"))
    conda:
        CORE_ENV
    threads: 1
    params:
        phage_ids=",".join(PHAGE_IDS),
        out_dir=lambda wc: str(STRUCT_DIR / wc.host_id),
        cmd=lambda wc, input, output: (
            f"python scripts/modules/foldseek_summarise.py --host-id {wc.host_id} --phage-ids {','.join(PHAGE_IDS)} "
            f"--out-dir {STRUCT_DIR / wc.host_id} "
            + ("--mock" if TEST_MODE else f"--hits-tsv {input['hits']}")
        )
    shell:
        "{params.cmd}"


# ---------- Decision bundle assembly ----------
rule decision_bundle:
    input:
        similarity = (lambda wc: expand(rules.similarity_feature.output, host_id=wc.host_id, phage_id=PHAGE_IDS)) if ENABLE_SIM else [],
        structural = rules.structural_features.output if ENABLE_STRUCT else [],
        safety = (lambda wc: expand(rules.safety_feature.output, phage_id=PHAGE_IDS)) if ENABLE_SAFETY else []
    output:
        ranking=str(RANKINGS_DIR / "{host_id}" / "ranking.csv"),
        evidence=str(RANKINGS_DIR / "{host_id}" / "evidence_bundle.json")
    conda:
        CORE_ENV
    threads: 1
    shell:
        "python scripts/assemble_decision_bundle.py --host-id {wildcards.host_id} "
        "--config config.yaml --phage-manifest {PHAGE_MANIFEST} --host-manifest {HOST_MANIFEST} "
        "--similarity-dir {SIM_DIR} --structural-dir {STRUCT_DIR} --safety-dir {SAFETY_DIR} "
        "--out-ranking {output.ranking} --out-evidence {output.evidence}"

# Validate outputs (optional but useful for CI/demo)
rule validate_decision_bundle:
    input:
        ranking=lambda wc: ranking_csv(wc.host_id),
        evidence=lambda wc: evidence_json(wc.host_id),
        schema="contracts/decision_bundle/evidence_bundle.schema.json"
    output:
        touch(str(RANKINGS_DIR / "{host_id}" / "VALIDATED.txt"))
    conda:
        CORE_ENV
    threads: 1
    shell:
        "python scripts/validate_decision_bundle.py --ranking {input.ranking} "
        "--evidence {input.evidence} --schema {input.schema} "
        "&& echo. > {output}"

rule validate:
    input:
        expand(str(RANKINGS_DIR / "{host_id}" / "VALIDATED.txt"), host_id=HOST_IDS)
